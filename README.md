# JSON-to-Struct Streaming Parser

**jssp** is a C library for parsing JSON. It's a complementary project to [**jspp**](https://github.com/quietboil/jspp). It rides on top of _jspp_ and provides a semi-automatic way to extract required data from JSON.

## Motivation

_jspp_ provides a number of benefits for parsing JSON in a resource constrained environment. However the need to build a state machine to be able to parse text split into multiple fragments might be a bit daunting. Hence **jssp** was created. It generates automata to recognize specified elements in the JSON being parsed and execute data extraction actions.

> **Note** that at the moment the "match JSON specification" compiler is not available yet and only the run-time part of **jssp** has been implemented. You can review `hello_world` test case in `tests` that uses manually coded automata to get an idea what the compiler will generate.

## Features

In the spirit of _jspp_ this library continues to target severely resource constrained environments and offers:

- **No memory allocation** - With the exception of automatic stack allocation by C for function arguments and variables **jssp** does not allocate memory at all - it does not have any static variables, it does not allocate any memory dynamically. It also does not _require_ any memory allocation - static or dynamic - to be performed by the caller.
- **Streaming parsing** - A memory constrained device may not be able to receive the entire JSON message at once. **jssp** is able to parse data fragments as they becomes available and continue from the point where it left off when the next fragment arrives. 

Mainly though **jssp** is designed to offer:

- **Semi-automatic data extraction** from the JSON payloads. **jssp** compiler generates required state machines from the specification. Library user only needs to provide data extraction handlers - functions that are called when specified JSON elements are matched.

## Installation

**jssp** depends on [**jspp**](https://github.com/quietboil/jspp) which would need to be instaleld first. At the moment, once _jspp_ has been installed, the easiest way to install **jssp** is to make it a sibling project to _jspp_. For example, to install both you might execute these commands:
```sh
$ git clone https://github.com/quietboil/jspp
$ git clone https://github.com/quietboil/jssp
```
Then change the current directory to `jssp` and execute `make` to build the library.

> **Note:** if you are crosscompiling, create `config.mk` script and define the target compiler - `CC`, `CFLAGS`, `AR` - in that file.

## API Reference

### Callbacks

Data handling callback:
```h
typedef void (*data_cb_t)(const char * data, uint16_t data_length, uint8_t data_type, const jssp_context_t * context);
```
These are the functions that will receive JSON data recognized by _jspp_ and are expected to process them in some way. For instance store somewhere as a part of the `result` of the parsing.

Name and path recognition automata:
```h
typedef uint32_t (*jssp_name_scanner_cb_t)(uint32_t state, char next_char);
typedef uint32_t (*jssp_path_matcher_cb_t)(uint32_t state, uint8_t next_elem, data_cb_t * action);
```
The implementations for these 2 callbacks are generated by the **jssp** compiler. Unless you are planning to roll them manually (like the `hello_world` test case does), that's all you need to know.

### Init

```h
void jssp_init(jssp_t * jssp, jssp_path_matcher_cb_t path_matcher_cb, jssp_name_scanner_cb_t name_scanner_cb)
```
This function associates **jssp** with a particular JSON specification by setting state machines for the name and path recognition.

#### Usage Example

Let's say a JSON specification - `hello_world.json` - has been compiled. This would create `hello_world.c` and `hello_world.h` as the implementation of the required automata. This generated implementation, among other things, will create 2 functions that calculate state machines for name and path recognition:
```h
uint32_t hello_world_name_next_state(uint32_t state, char next_char);
uint32_t hello_world_next_path_state(uint32_t state, uint8_t next_elem, data_cb_t * action);
```
These 2 functions are the callbacks that `jssp_init` expects:
```c
jssp_t jssp;
jssp_init(&jssp, hello_world_next_path_state, hello_world_name_next_state);
```
> **Note:** depending on your needs **jssp** can be fit with the recognition automata only once and then this structure would be reused to parse JSON of the specified type. Or, if for example you will only ever execute a single request at a time and really only need one **jssp** instance, you could allocate it statically and re-fit it with different automata depending on what you are expecting to parse.

### Start

```h
uint8_t jssp_start(jssp_t * jssp, void * result, const char * json_text, uint16_t text_length);
```
This functions prepares **jssp** to parse new JSON payload, invokes the parser and executes matching actions until it encounters either the end of the fragment or parses the entire JSON (if it fit entirely in the first fragment).

This function returns:
- `JSON_END` if JSON is completely processed.
- `JSON_CONTINUE` if JSON parser (_jspp_) needs to see the rest of the payload (that would arrive later in the subsequent fragments) to finish data extraction.
- `JSON_INVALID` if JSON parser encountered an invalid JSON and cannot continue parsing it.
- `JSON_TOO_DEEP` if the JSON being parsed has more levels of nesting than the library can handle. If such deeply nested structures are expected, then  _jspp_ needs to be altered (JSON_MAX_STACK increased) and recompiled.

### Continue

```h
uint8_t jssp_continue(jssp_t * jssp, const char * json_text, uint16_t text_length);
```
This function is called to continue data extraction from the second and sunsequent JSON fragments. It returns the same codes as `jssp_start`.

## Tests

To build **jssp** unit tests go to the `tests` directory and execute `make`:
```sh
$ cd tests
$ make
```

> **Note:** `tests` makefile assumes that _jspp_ is installed as a sibling project as outlined in the Installation.

This will build a single executable that contains all unit tests. To run them execute:
```sh
tests
```
